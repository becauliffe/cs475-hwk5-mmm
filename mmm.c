#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 */

void mmm_colInit(int SIZE, double **matrix)
{

	int j;
	for (int i = 0; i < SIZE; i++)
	{
		for (j = 0; j < SIZE; j++)
		{
			matrix[i][j] = rand() % 100;
		}
	}
}
void mmm_rowInit(int SIZE, double **matrix)
{
	int j;
	for (int i = 0; i < SIZE; i++)
	{
		for (j = 0; j < SIZE; j++)
		{
			matrix[j][i] = rand() % 100;
		}
	}
}

/**
 * Reset a given matrix to zeroes
 * @param matrix pointer to a 2D array
 */
void mmm_reset(double **matrix, int SIZE)
{
	for (int i = 0; i < SIZE; i++)
	{
		memset(matrix[i], 0, SIZE * sizeof(double *));
	}
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup()
{
	// TODO
}
double **mmm_create(int SIZE)
{
	double **matrix = (double **)malloc(SIZE * sizeof(double *));
	for (int i = 0; i < SIZE; i++)
	{
		matrix[i] = (double *)malloc(SIZE * sizeof(double));
	}
	return matrix;
}
/**
 * Sequential MMM
 */
void mmm_seq(mmm_args *args)
{
	for (int i = 0; i < args->SIZE; i++)
	{ // row
		for (int j = 0; j < args->SIZE; j++)
		{ // col
			int temp = 0;
			for (int k = 0; k < args->SIZE; k++)
			{
				temp += (args->one[i][k] * args->two[j][k]); // remember two is rotated
			}
			args->prod[i][j] = temp;
		}
	}
}

/**
 * Parallel MMM
 */
void *mmm_par(void *args)
{

	mmm_args *margs = args;
	for (int i = margs->start; i < margs->end; i++)
	{ // row
		for (int j = 0; j < margs->SIZE; j++)
		{ // col
			int temp = 0;
			for (int k = 0; k < margs->SIZE; k++)
			{
				temp += (margs->one[i][k] * margs->two[j][k]); // remember two is rotated
			}
			margs->prod[i][j] = temp;
		}
	}
	return NULL;
}

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify()
{
	// TODO
	return -1;
}
